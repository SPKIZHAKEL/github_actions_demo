Caching -
speed up workflows runs by caching stable file
it allows to store files and retrieve them based on a key.  
workflpw can access the cache from their brnach or from default branch

worlflow:
wroflow run starts-> execute cache step -> cache matching key? if yes-> restore cache
if no-> then install dependencies

When is the cache reused?

Only when the cache key matches.

key: ubuntu-latest-npm-<hash>

Same key → cache reused
Different key → new cache created
Real example with dependencies
First run
key: ubuntu-latest-npm-AAA


Cache does not exist → create it.

Second run (same deps)
key: ubuntu-latest-npm-AAA


Cache exists → reuse it.

After adding a dependency

package-lock.json changes → hash changes:

key: ubuntu-latest-npm-BBB


Old cache not reused → new cache created.



####################################################

2️⃣ How cache can still be reused

Even though the runner doesn’t persist the cache, GitHub Actions uploads the cache to GitHub storage after the step/job finishes.

Later jobs (or later workflow runs) can download the cache from GitHub storage using the same key.

3️⃣ Illustration
Job 1 (fresh runner)
 ├─ step: restore cache → downloaded to runner
 ├─ step: use node_modules
 └─ end of job → runner destroyed, cache uploaded to GitHub storage

Job 2 (fresh runner)
 ├─ step: restore cache → downloaded from GitHub storage to new runner
 └─ step: use node_modules


Each job gets a new runner, so nothing is left behind from previous jobs.

Only the cache uploaded to GitHub storage persists between jobs.


#####################################################################

Workflow Run
┌───────────────────────────┐
│ Job 1:                     │
│ ┌───────────────────────┐ │
│ │ Step 1: Restore cache  │ │
│ │ Key = os-node-<hash>   │ │
│ │ ┌───────────────────┐ │ │
│ │ │ Cache found?      │ │ │
│ │ │ Yes → restore to  │ │ │
│ │ │ path: node_modules│ │ │
│ │ └───────────────────┘ │ │
│ └───────────────────────┘ │
│ ┌───────────────────────┐ │
│ │ Step 2: Use node_modules│ │
│ └───────────────────────┘ │
│ End of Job → Runner is destroyed │
│ Cache uploaded to GitHub Storage │
└───────────────────────────┘

┌───────────────────────────┐
│ Job 2 (same workflow or later run) │
│ ┌───────────────────────┐ │
│ │ Step 1: Restore cache  │ │
│ │ Key = os-node-<hash>   │ │
│ │ ┌───────────────────┐ │ │
│ │ │ Cache found?      │ │ │
│ │ │ Yes → restore to  │ │ │
│ │ │ path: node_modules│ │ │
│ │ └───────────────────┘ │ │
│ └───────────────────────┘ │
│ ┌───────────────────────┐ │
│ │ Step 2: Use node_modules│ │
│ └───────────────────────┘ │
│ End of Job → Runner destroyed │
└───────────────────────────┘

Cache key (os-node-<hash>) determines which cache is restored.

Restored cache goes to the path you specify (e.g., node_modules) in the runner.

Runner is ephemeral — everything disappears after the job finishes.

Cache is stored remotely in GitHub storage and can be reused in future jobs/runs if the key matches.